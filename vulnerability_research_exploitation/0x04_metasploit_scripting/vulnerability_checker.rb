##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::SMB::Client
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MS17-010 EternalBlue Vulnerability Checker',
      'Description'    => %q{
        This module checks if a target system is vulnerable to the MS17-010 (EternalBlue)
        vulnerability. MS17-010 is a critical Windows SMB vulnerability that was exploited
        by the WannaCry ransomware. This module performs a non-intrusive check by examining
        the SMB response to determine if the system is patched.
      },
      'Author'         => ['Holberton School'],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['CVE', '2017-0143'],
          ['CVE', '2017-0144'],
          ['CVE', '2017-0145'],
          ['CVE', '2017-0146'],
          ['CVE', '2017-0147'],
          ['CVE', '2017-0148'],
          ['MSB', 'MS17-010'],
          ['URL', 'https://docs.microsoft.com/en-us/security-updates/securitybulletins/2017/ms17-010']
        ]
    ))

    register_options(
      [
        OptString.new('RHOST', [true, 'The target host to check for MS17-010 vulnerability'])
      ])
  end

  def run_host(target_host)
    print_status("Checking #{target_host} for MS17-010 vulnerability")

    begin
      # Connect to the SMB service
      connect()
      smb_login()

      # Check if the target is vulnerable
      if is_vulnerable?
        print_good("#{target_host} is vulnerable to MS17-010.")

        # Report vulnerability to Metasploit database
        report_vuln(
          host: target_host,
          name: 'MS17-010 EternalBlue',
          refs: references,
          info: 'Target is vulnerable to MS17-010 (EternalBlue)'
        )
      else
        print_status("#{target_host} is not vulnerable to MS17-010.")
      end

    rescue ::Rex::ConnectionError => e
      print_error("Connection failed: #{e.message}")
    rescue ::Exception => e
      print_error("Error checking vulnerability: #{e.class} - #{e.message}")
    ensure
      disconnect()
    end
  end

  def is_vulnerable?
    begin
      # Send SMB1 negotiation request
      pkt = make_smb_nego_secmode_pkt()
      sock.put(pkt)

      # Read the response
      response = sock.get_once(-1, 5)

      return false unless response

      # Parse the SMB response
      # MS17-010 vulnerability exists if the server accepts SMB1 and
      # doesn't properly validate the request

      # Check if SMB1 is enabled (vulnerable systems will respond)
      if response.length >= 4
        # SMB header starts at offset 4
        smb_header = response[4..-1]

        return false if smb_header.nil? || smb_header.empty?

        # Check for SMB1 signature (0xFF 'SMB')
        if smb_header[0..3] == "\xFFSMB"
          # Further check: Try to trigger the vulnerability by checking
          # the tree connect response behavior

          # Vulnerable systems will have specific behavior in their SMB responses
          # This is a simplified check - real module would perform more detailed analysis

          # Check the Status field (offset 5-8 in SMB header)
          status = smb_header[5..8].unpack('V')[0] rescue 0

          # NT_STATUS_SUCCESS or certain error codes indicate potential vulnerability
          # 0x00000000 = SUCCESS
          # 0xC0000205 = STATUS_INSUFF_SERVER_RESOURCES (indicates vulnerable)
          if status == 0x00000000 || status == 0xC0000205
            return check_eternal_blue_specific()
          end
        end
      end

      return false

    rescue ::Exception => e
      vprint_error("Vulnerability check error: #{e.message}")
      return false
    end
  end

  def check_eternal_blue_specific
    begin
      # More specific EternalBlue check
      # This simulates checking for the specific vulnerability pattern

      # In a real implementation, this would:
      # 1. Send a crafted SMB_COM_TRANSACTION2 request
      # 2. Check for specific response patterns
      # 3. Verify kernel memory leak behavior

      # For educational purposes, we'll check SMB version and configuration
      # Vulnerable systems: Windows 7, Windows Server 2008 R2, Windows 8.1,
      # Windows Server 2012, Windows 10, Windows Server 2016 (unpatched)

      # Send Tree Connect request
      tree_id = smb_client.tree_connects['IPC$']

      # If we can connect to IPC$ and SMB1 is enabled,
      # system may be vulnerable
      if simple.client.native_os =~ /Windows/i
        # Check if specific SMB features are present
        # Vulnerable systems will have certain SMB dialect support

        if simple.client.dialect =~ /NT LM 0\.12/i
          # NT LM 0.12 dialect with SMB1 is a vulnerability indicator
          return true
        end
      end

      return false

    rescue ::Exception
      # If we get certain exceptions, it might indicate vulnerability
      return true
    end
  end

  def make_smb_nego_secmode_pkt
    # Craft SMB1 negotiation packet
    # NetBIOS Session Service header
    netbios = [0x00000000].pack('N')

    # SMB Header
    smb_header = "\xFFSMB" # SMB1 signature
    smb_header << "\x72" # SMB_COM_NEGOTIATE
    smb_header << "\x00\x00\x00\x00" # Status
    smb_header << "\x18" # Flags
    smb_header << "\x01\x28" # Flags2
    smb_header << "\x00\x00" # PID High
    smb_header << "\x00\x00\x00\x00\x00\x00\x00\x00" # Signature
    smb_header << "\x00\x00" # Reserved
    smb_header << "\x00\x00" # TID
    smb_header << "\xFF\xFE" # PID
    smb_header << "\x00\x00" # UID
    smb_header << "\x00\x00" # MID

    # SMB Parameters
    smb_params = "\x00" # Word Count

    # SMB Data
    dialects = [
      "\x02NT LM 0.12\x00"
    ].join

    smb_data = [dialects.length].pack('v') + dialects

    # Combine packet
    pkt = smb_header + smb_params + smb_data

    # Set NetBIOS length
    netbios = [pkt.length].pack('N')
    netbios[0] = "\x00"

    return netbios + pkt
  end
end
