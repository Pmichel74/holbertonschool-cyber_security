##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name'           => 'Custom Port Scanner',
        'Description'    => %q{
          This module scans a range of ports on a target system and identifies
          which ones are open. It provides a simple TCP port scanning capability
          to discover open services on remote hosts.
        },
        'Author'         => ['Holberton School'],
        'License'        => MSF_LICENSE,
        'References'     => []
      )
    )

    register_options(
      [
        OptInt.new('STARTPORT', [true, 'The starting port number to scan', 1]),
        OptInt.new('ENDPORT', [true, 'The ending port number to scan', 1000]),
        OptInt.new('TIMEOUT', [true, 'Connection timeout in seconds', 1])
      ]
    )
  end

  def run_host(target_host)
    start_port = datastore['STARTPORT']
    end_port = datastore['ENDPORT']
    timeout = datastore['TIMEOUT']
    open_ports = []

    # Validate port range
    if start_port < 1 || start_port > 65535
      print_error("Invalid STARTPORT: #{start_port}. Must be between 1 and 65535.")
      return
    end

    if end_port < 1 || end_port > 65535
      print_error("Invalid ENDPORT: #{end_port}. Must be between 1 and 65535.")
      return
    end

    if start_port > end_port
      print_error("STARTPORT (#{start_port}) cannot be greater than ENDPORT (#{end_port}).")
      return
    end

    print_status("Running module against #{target_host}")
    print_line("")

    # Scan the port range
    (start_port..end_port).each do |port|
      begin
        # Attempt to connect to the port
        sock = Rex::Socket::Tcp.create(
          'PeerHost' => target_host,
          'PeerPort' => port,
          'Context'  => {
            'Msf'        => framework,
            'MsfExploit' => self
          },
          'Timeout'  => timeout
        )

        # If connection succeeds, the port is open
        if sock
          print_good("#{target_host}:#{port} - Port #{port} is open on #{target_host}")
          open_ports << port

          # Report the open port to the database
          report_service(
            host: target_host,
            port: port,
            proto: 'tcp',
            state: 'open'
          )

          # Close the socket
          sock.close
        end

      rescue ::Rex::ConnectionError, ::Rex::ConnectionRefused, ::Rex::HostUnreachable, ::Rex::ConnectionTimeout, ::Timeout::Error, ::Errno::ETIMEDOUT
        # Port is closed or filtered, continue to next port
        next
      rescue ::Exception => e
        # Handle any unexpected errors
        vprint_error("Error scanning port #{port}: #{e.class} - #{e.message}")
        next
      end
    end

    # Print summary of open ports
    if open_ports.empty?
      print_status("#{target_host}:#{start_port} - No open ports found on #{target_host} in range #{start_port}-#{end_port}")
    else
      print_status("#{target_host}:#{open_ports.first} - Open ports on #{target_host}: #{open_ports.join(', ')}")
    end
  end
end
